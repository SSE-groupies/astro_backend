name: Azure Container App Deployment

# Environment Protection Rules:
# To set up manual approvals for production deployments:
# 1. Go to your repository settings > Environments
# 2. Create a 'production' environment if it doesn't exist
# 3. Under "Environment protection rules", enable "Required reviewers"
# 4. Add the required reviewers who can approve production deployments
# 5. Optionally, add deployment branches rule to limit production deployments to specific branches

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      packages: write
      security-events: write

    outputs:
      # We need to conditionally skip deployments for pull requests
      should_deploy: ${{ github.event_name != 'pull_request' }}
      image_tag: ${{ steps.meta.outputs.tags }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        if: github.event_name != 'pull_request'

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
          flavor: |
            latest=auto
        
      - name: Build Docker image
        id: docker_build
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./docker/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          load: ${{ github.event_name == 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Don't fail PR builds
          platforms: linux/amd64
      
      - name: Run Trivy vulnerability scanner on Docker image
        if: ${{ github.event_name == 'pull_request' }}
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'image'
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'table'
          exit-code: '0'  # Don't fail PR checks on vulnerable dependencies
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
        continue-on-error: true
        
      - name: Run Trivy vulnerability scanner on Docker image (strict)
        if: ${{ github.event_name != 'pull_request' }}
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'image'
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          exit-code: '0'  # Changed to not fail the workflow
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
        continue-on-error: true
            
      - name: Upload Trivy scan results to GitHub Security tab
        if: ${{ github.event_name != 'pull_request' && success() }}
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true
      
      - name: Scan Dockerfile
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          hide-progress: false
          format: 'table'
          exit-code: '0'  # Don't fail on dockerfile issues for now
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
          input: './docker/Dockerfile'
        continue-on-error: true

  # Pre-deployment validation job
  pre-deployment-validation:
    name: Pre-Deployment Validation
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install safety bandit
        
    - name: Run security checks
      run: |
        echo "Running security checks before deployment..."
        safety check || echo "Safety check failed, but continuing"
        # Skip B104 (hardcoded_bind_all_interfaces) since binding to 0.0.0.0 is expected for containerized apps
        bandit -r ./ -ll -ii -x ./tests -s B104 || echo "Bandit found issues, but continuing"
      continue-on-error: true
        
    - name: Validate configuration
      run: |
        echo "Validating deployment configuration..."
        # Check if all required secrets are available
        if [ -z "${{ secrets.AZURE_CREDENTIALS }}" ]; then
          echo "Error: AZURE_CREDENTIALS is not set"
          exit 1
        fi
        if [ -z "${{ secrets.AZURE_RESOURCE_GROUP }}" ]; then
          echo "Error: AZURE_RESOURCE_GROUP is not set"
          exit 1
        fi
        if [ -z "${{ secrets.AZURE_CONTAINER_ENV }}" ]; then
          echo "Error: AZURE_CONTAINER_ENV is not set"
          exit 1
        fi
        if [ -z "${{ secrets.AZURE_CONTAINER_APP }}" ]; then
          echo "Error: AZURE_CONTAINER_APP is not set"
          exit 1
        fi
        
        echo "All required secrets are available."
        echo "Pre-deployment validation passed!"

  # Environment setup job
  prepare-environment:
    name: Prepare Azure Environment
    needs: pre-deployment-validation
    # Skip this job for pull requests
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    outputs:
      resource_group: ${{ steps.set_variables.outputs.resource_group }}
      location: ${{ steps.set_variables.outputs.location }}
      env_name: ${{ steps.set_variables.outputs.env_name }}
      app_name: ${{ steps.set_variables.outputs.app_name }}
      
    steps:
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Set environment variables
      id: set_variables
      run: |
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        LOCATION="${{ secrets.AZURE_LOCATION }}"
        ENV_NAME="${{ secrets.AZURE_CONTAINER_ENV }}"
        APP_NAME="${{ secrets.AZURE_CONTAINER_APP }}"
        
        echo "resource_group=$RG" >> $GITHUB_OUTPUT
        echo "location=$LOCATION" >> $GITHUB_OUTPUT
        echo "env_name=$ENV_NAME" >> $GITHUB_OUTPUT
        echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
        
        # Debug output
        echo "Resource Group: $RG"
        echo "Location: $LOCATION"
        echo "Environment Name: $ENV_NAME"
        echo "App Name: $APP_NAME"
        
        # Verify required variables are set
        if [ -z "$RG" ]; then
          echo "Error: AZURE_RESOURCE_GROUP is not set"
          exit 1
        fi
        
        if [ -z "$LOCATION" ]; then
          echo "Error: AZURE_LOCATION is not set"
          exit 1
        fi
        
    - name: Create resource group if needed
      uses: azure/CLI@v1
      with:
        inlineScript: |
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          LOCATION="${{ secrets.AZURE_LOCATION }}"
          
          # Check if resource group exists
          echo "Checking resource group '$RG'..."
          if az group exists --name "$RG"; then
            echo "Resource group '$RG' exists"
          else
            echo "Creating resource group '$RG' in '$LOCATION'..."
            az group create --name "$RG" --location "$LOCATION"
          fi
    
    - name: Create container app environment if needed
      uses: azure/CLI@v1
      with:
        inlineScript: |
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          ENV_NAME="${{ secrets.AZURE_CONTAINER_ENV }}"
          LOCATION="${{ secrets.AZURE_LOCATION }}"
          
          # Check if container app environment exists
          echo "Checking container app environment '$ENV_NAME'..."
          if az containerapp env show --name "$ENV_NAME" --resource-group "$RG" --query "name" -o tsv 2>/dev/null; then
            echo "Container app environment exists"
          else
            echo "Creating container app environment..."
            az containerapp env create \
              --name "$ENV_NAME" \
              --resource-group "$RG" \
              --location "$LOCATION"
          fi

  # Main deployment job
  deploy:
    name: Deploy Container App
    needs: [prepare-environment, build-and-test]
    # Skip this job for pull requests
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    outputs:
      app_url: ${{ steps.deploy.outputs.app_url }}
      
    steps:
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Save current image for rollback
      id: get_current_image
      continue-on-error: true
      run: |
        RG="${{ needs.prepare-environment.outputs.resource_group }}"
        APP_NAME="${{ needs.prepare-environment.outputs.app_name }}"
        
        if az containerapp show --name "$APP_NAME" --resource-group "$RG" --query "properties.template.containers[0].image" -o tsv 2>/dev/null; then
          CURRENT_IMAGE=$(az containerapp show --name "$APP_NAME" --resource-group "$RG" --query "properties.template.containers[0].image" -o tsv)
          echo "current_image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT
          echo "Current image: $CURRENT_IMAGE"
        else
          echo "No current image found"
        fi
    
    - name: Deploy to Azure Container App
      id: deploy
      uses: azure/CLI@v1
      with:
        inlineScript: |
          RG="${{ needs.prepare-environment.outputs.resource_group }}"
          ENV_NAME="${{ needs.prepare-environment.outputs.env_name }}"
          APP_NAME="${{ needs.prepare-environment.outputs.app_name }}"
          
          # Get the first image tag - handle multiline output safely
          IMAGE_TAG=$(echo "${{ needs.build-and-test.outputs.image_tag }}" | head -n 1)
          echo "Using image: $IMAGE_TAG"
          
          # Check if container app exists
          echo "Checking if container app '$APP_NAME' exists..."
          if az containerapp show --name "$APP_NAME" --resource-group "$RG" --query "name" -o tsv 2>/dev/null; then
            echo "Updating existing container app..."
            az containerapp update \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --image "$IMAGE_TAG" \
              --set-env-vars \
                "ENVIRONMENT=${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}" \
                "PORT=8080" \
                "AZURE_STORAGE_USE_MANAGED_IDENTITY=${{ github.ref == 'refs/heads/main' && 'true' || 'false' }}" \
                "AZURE_STORAGE_ACCOUNT_URL=${{ secrets.AZURE_STORAGE_ACCOUNT_URL }}" \
                "AZURE_STORAGE_CONNECTION_STRING=${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" \
                "REDIS_HOST=${{ secrets.REDIS_HOST }}" \
                "REDIS_PORT=${{ secrets.REDIS_PORT }}" \
                "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" \
                "REDIS_SSL=true" \
                "API_CORS_ORIGINS=${{ secrets.API_CORS_ORIGINS }}" \
                "ADMIN_API_KEY=${{ secrets.ADMIN_API_KEY }}" \
              --target-port 8080 \
              --ingress external \
              --min-replicas 1 \
              --max-replicas 3 \
              --cpu 0.5 \
              --memory 1.0Gi \
              --probe-path /health \
              --probe-protocol HTTP \
              --probe-interval 30 \
              --probe-timeout 10 \
              --probe-retries 3
          else
            echo "Creating new container app..."
            az containerapp create \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --environment "$ENV_NAME" \
              --image "$IMAGE_TAG" \
              --target-port 8080 \
              --ingress external \
              --min-replicas 1 \
              --max-replicas 3 \
              --cpu 0.5 \
              --memory 1.0Gi \
              --env-vars \
                "ENVIRONMENT=${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}" \
                "PORT=8080" \
                "AZURE_STORAGE_USE_MANAGED_IDENTITY=${{ github.ref == 'refs/heads/main' && 'true' || 'false' }}" \
                "AZURE_STORAGE_ACCOUNT_URL=${{ secrets.AZURE_STORAGE_ACCOUNT_URL }}" \
                "AZURE_STORAGE_CONNECTION_STRING=${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" \
                "REDIS_HOST=${{ secrets.REDIS_HOST }}" \
                "REDIS_PORT=${{ secrets.REDIS_PORT }}" \
                "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" \
                "REDIS_SSL=true" \
                "API_CORS_ORIGINS=${{ secrets.API_CORS_ORIGINS }}" \
                "ADMIN_API_KEY=${{ secrets.ADMIN_API_KEY }}" \
              --probe-path /health \
              --probe-protocol HTTP \
              --probe-interval 30 \
              --probe-timeout 10 \
              --probe-retries 3
          fi
          
          # Get and store the app URL
          APP_URL=$(az containerapp show --name "$APP_NAME" --resource-group "$RG" --query "properties.configuration.ingress.fqdn" -o tsv)
          echo "Container App URL: $APP_URL"
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT

  # Final verification job
  verify:
    name: Verify Deployment
    needs: deploy
    # Skip this job for pull requests
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    
    steps:
    - name: Health check
      id: health_check
      run: |
        APP_URL="${{ needs.deploy.outputs.app_url }}"
        MAX_RETRIES=30
        RETRY_INTERVAL=10
        
        # Check basic health endpoint first
        echo "Checking basic health endpoint..."
        for i in $(seq 1 $MAX_RETRIES); do
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_URL/health")
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "Basic health check passed!"
            break
          fi
          echo "Attempt $i/$MAX_RETRIES: Health check failed with status $HTTP_STATUS. Retrying in ${RETRY_INTERVAL}s..."
          sleep $RETRY_INTERVAL
          
          if [ "$i" = "$MAX_RETRIES" ]; then
            echo "Basic health check failed after $MAX_RETRIES attempts"
            exit 1
          fi
        done
        
        # Now check readiness endpoint
        echo "Checking readiness endpoint..."
        for i in $(seq 1 5); do
          READINESS=$(curl -s "https://$APP_URL/health/readiness")
          echo "Readiness response: $READINESS"
          
          if [[ "$READINESS" == *"ready"* ]]; then
            echo "Application is ready!"
            exit 0
          fi
          
          echo "Attempt $i/5: Readiness check not successful. Retrying in ${RETRY_INTERVAL}s..."
          sleep $RETRY_INTERVAL
        done
        
        echo "Readiness check failed after 5 attempts"
        exit 1
    
    - name: Functional verification
      run: |
        APP_URL="${{ needs.deploy.outputs.app_url }}"
        
        # Add additional functional verification here
        echo "Running post-deployment functional tests..."
        # Check the redis info endpoint
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_URL/health/redis")
        if [ "$HTTP_STATUS" = "200" ]; then
          echo "Redis health check passed!"
        else
          echo "Redis health check failed with status $HTTP_STATUS"
          # Don't fail the build for this check
        fi
        
        # Check the diagnostics endpoint
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_URL/health/diagnostics")
        echo "Diagnostics endpoint status: $HTTP_STATUS"
        
    - name: Send deployment notification
      if: always()
      run: |
        STATUS="${{ job.status }}"
        APP_URL="${{ needs.deploy.outputs.app_url }}"
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}"
        
        echo "Deployment Status: $STATUS"
        echo "App URL: $APP_URL"
        echo "Environment: $ENVIRONMENT"
        
        # Here you could add code to send notifications to Slack, Teams, etc.
        # For example, using webhook:
        # curl -X POST -H 'Content-type: application/json' --data '{"text":"Deployment to '"$ENVIRONMENT"' '"$STATUS"': '"$APP_URL"'"}' ${{ secrets.SLACK_WEBHOOK_URL }} 